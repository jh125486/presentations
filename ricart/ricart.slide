An Optimal Algorithm for Mutual Exclusion in Computer Networks
(Ricart-Agrawala algorithm)
13 Feb 2018

Sampson Akwafuo
Jacob Hochstetler
CSCE6640
University of North Texas

* Overview

1. Introduction

2. Algorithm

3. Assertions

4. Message Traffic

5. Delay in Granting CS

6. Further Modifications

8. Conclusion

* Introduction

- A novel algorithm for requesting and creating mutual exclusion
- Only 2*( _N_-1) messages are sent and received (33% less than Lamport's)
- Uses global ordering of events through a logical clock

Three techniques can be used to achieve *minimal* number of messages:

- Sequential node-by-node processing
- Broadcast message
- Sending information through timing channels

* Algorithm [Overview]

*Requesting*node*

1. Sends a *REQUEST* to all nodes with the node number and current timestamp

*Receiving*node*

1. Upon reception of a *REQUEST*, immediately sends a timestamped *REPLY* iff:

- is not currently interested in the critical section _OR_
- has a lower priority by a later timestamp or tie-breaker higher node number

2. Else the receiver defers *REPLY* until after exiting CS

_Critical_Section_
1) Requesting node enters CS only after receiving *REPLY* from all nodes
2) Upon exiting CS the node sends all deferred *REPLYs*

* Algorithm [Optimality]

- Number of messages is minimal
- Delay/Time needed to achieve Mutual Exclusion (mutex) is minimal
- Priority is based on first-come, first-served basis

* Algorithm [Assumptions]

- Transactions are made on an error-free channel of communication, with varying latency
- Nodes act symmetrically, without access to timing derived information
- Nodes operates correctly

* Algorithm [Example]

.image images/example.png

* Assertions [Mutual Exclusion]

Mutual exclusion is achieved when *no* *pair* of nodes is ever simultaneously in its _CS_

*Proof* (by contradiction):

*Case*1*: Node _A_ sent a *REPLY* to Node _B's_ *REQUEST* before choosing its own sequence number. Therefore _A_ will choose a sequence number higher than _B's_ sequence number. When _B_ received _A's_ *REQUEST* with a higher number it must have found _RequestingCS_ == *TRUE* since it is set before sending a *REQUEST*. The algorithm directs _B_ to defer the *REQUEST* and not reply until it has left CS. Then Node _A_ could not yet be in its CS contrary to assumption.

*Case*2*: Node _B_ sent a *REPLY* to _A's_ *REQUEST* before choosing its own sequence number. Mirror of *Case*1*.

*Case*3*: Both nodes sent a *REPLY* to the other's *REQUEST* after choosing their own sequence number. Both must have found _RequestingCS_ == *TRUE*. Both will compare the sequence number and node number in the *REQUEST* and exactly one will defer the *REQUEST* until it has left CS contradicting the assumption.

* Assertions [Deadlock]

* Assertions [Starvation]

* Message Traffic

* Delay in Granting CS [Compliance]

1. Case A

2. Case B


* Modifications

- Implicit Reply
- Broadcast Messages
- Ring Structure
- Bounding Sequence Numbers
- Sequence Number Incrementation
- Readers and Writers

* Modifications [Implicit Reply]

* Modifications [Broadcast Messages]

- Communications medium sequencing
- No communications medium sequencing

* Modifications [Ring Structure]

* Modifications [Bounding Sequence Numbers]

* Modifications [Sequence Number Incrementation]

Two situations where incrementing sequence numbers _unconventionally_ makes sense:

- Reducing lower-numbered node favoritism by incrementing seq. # by a random INT
- Forcing priority through using small increments on high priority nodes

* Modifications [Readers and Writers Problem]

*"Writers"* given priority by:

- *"Readers"* never defer a REQUEST for another *"reader"* => immediately REPLY
- *"Writers"* follow original algorithm

* Considerations for Practical Networks
- Node Numbers
- Insertion of New Nodes
- Removal of Nodes
- Node Failures

* Considerations [Node Numbers]

- Use a map to get the actual node number from a range larger than 1..._N_

* Considerations [Insertion of New Nodes]

1. Must be assigned unique node numbers
2. Obtain the full list of participating nodes
3. All other nodes must be notified of the new node
4. New _Highest__Sequence__Number_ must be updated

Additionally, if the node previously failed:

- Restart interval

* Considerations [Removal of Nodes]

- Broadcast to all other nodes intention to leave
- Other nodes must send an acknowledge message
- During request, leaving node cannot request mutex & must REPLY to REQUESTs
- Other nodes remove the node from NAMES & decrements active nodes _N_

* Considerations [Node Failures]

- Timeout-recovery method must be added for detection of failed nodes
- Only message requiring detection: REQUEST
- Must have prior knowledge of both the time for a node to respond (upper bound) and a node's maximum time within a critical section (estimate)
- A failed node may rejoin through the new node mechanism

* Conclusion
