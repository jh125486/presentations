# An Extensible Computing Architecture Design for Connected Autonomous Vehicle System

Jacob Hochstetler
PhD Dissertation Defense
Dr. Song Fu 
Dr. Rodney Nielsen
Dr. Armin Mikler 
Dr. Ryan Garlick
jacobhochstetler@my.unt.edu
http://github.com/jh125486

: Thank everyone for attending

## Organization

1. Introduction

2. Background

3. Problems and challenges

4. Extensible Edge Computing Architecture

<div style="margin: -0.5em 0">
&emsp;&emsp;&bull; Data format/protocol

&emsp;&emsp;&bull; Application orchestration
</div>

5. Other PhD research

<div style="margin: -0.5em 0">
&emsp;&emsp;&bull; Cloud/Edge-related

&emsp;&emsp;&bull; CAV-related
</div>

6. Conclusion & future work

7. Publications

: Read bullets

## Introduction: Computing Hierarchy

.image images/network_overview.png 530 _
.caption Connected computing hierarchy 

: Starting off, this is a graphic representing the hierarchy of computing that my design encompasses.

: At the top, we have the cloud data centers, with vast computing power, infinite but metered usage, but high-latency to get data there.

: At the bottom we have far edge devices, which are end-user devices like cell phones, or more importantly for my work, connected vehicles.  
: These devices are the most resource-constrained and even have to deal with power throttling due to battery limitations. For connected vehicles, this is where all the data and sensor collection takes place.

: In the middle we have the near edge, which is located in small local datacenters, or in colos at the base of cell towers. 
: The near edge devices were created to fill the "goldilocks gap" in data latency between the cloud and end-user devices.

## Introduction: Edge

&nbsp;
&nbsp;
&nbsp;

&nbsp;
&nbsp;
&nbsp;

.image images/edge.png _ 1000 
.caption At every network layer, there exists Edge devices

## Background: Decentralized computing

- Cloud computing
    - Treating 'compute' like a utility
    - IaaS: <b>I</b>nfrastructure <b>a</b>s <b>a</b> <b>S</b>ervice (OS, application & data)
    - PaaS: <b>P</b>latform <b>a</b>s <b>a</b> <b>S</b>ervice (application & data)
    - SaaS: <b>S</b>oftware <b>a</b>s <b>a</b> <b>S</b>ervice (only data)

- Ubiquitous computing
    - Rise of embedded devices and IoT computing
    - Reducing the 'computer' interface, e.g. Apple Watch

- Connected vehicles
    - Connected and Autonomous Vehicles (CAV)
    - CAV ⇄ Edge /  Edge ⇄ Cloud / CAV ⇄ Cloud

: Everyone should be familiar with Cloud computing at this point, but only real background information needed is the transition to treating infrastructure like a utility, and the move to differentiating and segmenting services.
: Ubiquitous computing is a term for the recent evolution of computing that isn't taking place in normal human-computer interfaces.
: Vehicles that can both talk to cloud services over cell service/wifi and communicate with other vehicles over protocols like DSRC, dedicated short range communications. 

## Background: In-Vehicle services and systems

- Real-time diagnostics
    - Started with standardized engine emission collection in 1994 (OBD-II)
    - Independent RT diagnostics from separate manufacturers, mostly Satcom-based
    - Modern systems use 3G/4G/LTE to haul data to cloud providers

- Advanced Driver-Assistant Systems (ADAS)
    - Camera/radar/LiDAR/Sonar (ultrasonic)-based
    - From basic self-parking to highway lane "keeping" and 'smart cruise control'

- Third-party applications
    - *Now*: 'Infotainment' with integrated 1<sup>st</sup> and 2<sup>nd</sup>-party applications
    - *Future*: 3<sup>rd</sup>-party applications (and government-party)

: 1st party applications like navigation and 2nd party apps like Satellite radio from VARs, or even insurance apps for commerical businesses like long-haul trucking.
: 3rd party apps like Android auto, or Apple Carplay along with new directions like government provided applications to monitor roads traveled, miles driven (for tax purposes), or even using onboard cameras to scan for license plates ala Amber alert.

: FIAT Blue&Me 
: Ford RESCU & VEMS/Ford SYNC/MyFord/MyLincoln Touch
: Hyundai Blue Link
: GM OnStar 
: NissanConnect
: Lexus Link 
: Toyota Safety Connect 
: Lexus Remote Touch
: Mercedes-Benz COMAND 
: Porsche Car Connect

## Background: Vehicle Data Producers/Sensors

.image images/sensors.png 550 _

: One thing not shown is convolutional feature maps. This is a placeholder for models generated by the onboard computer inferred from one or more sensors, possibly even fusion from multiple sensor types.  
: This semi-processed data can then be shared to other vehicles, or edge systems, for example road-side nodes, streetlight cameras.

## Our proposed CAV/Edge/Cloud architecture

.image images/prior_work_overview.png _ 1024 

: This is an overview of my prior work on the architecture, which is listed later in this presentation.
: My prior work is separated into three parts: Cloud-related, Edge-related, and CAV-related
: The lightening bolts represent network connections between devices, because in a diagram you always have to label the connections with lightening bolts just like a cloud data center must be represent by this same fluffy cloud graphic.

## Problems and challenges

1. Extensibility and compatibility
    - Breaking changes in models/services
    - Ability to maintain service older clients
    - Interoperability between different manufacturers

<hr style="margin: 2em 0 1.5em 0"/>

2. Data sharing
    - End-user privacy
    - Origination/maintenance of trust
    - Legal and moral facets of data retention

: I've explored two facets of creating a CAV ecosystem
: I've focused my work on point 1: extensibility and compatibility
: Point two will be future work I am pursuing.


## Focus on extensibility and compatibility

- Data format
- Data protocol
- 1<sup>st</sup> through 3<sup>rd</sup>-party integration

: This is needed for all the pieces to properly "talk"

<hr style="margin: 2em 0 1.5em 0"/>

: favorite, usually misquoted quote, from Butler Lampson
<div style="text-align:center;margin-top: 64px">
<i>"All problems in computer science can be solved by another level of indirection [abstraction]" <br/>
 . <br/>
 . <br/>
 . <br/>
"but that usually will  create another  problem"
</i>
</div>

.caption A favorite, misquoted quote from Butler Lampson


## Challenge: Data format

- Compatibility 
    - Backwards (new fields won't incur collisions)
    - Forwards (future clients accept 'older' versions)
    - No additional metadata (avoiding 'versioning' fields)

- Technical merits
    - Encoding size (literal size on the 'wire')
    - Speed (serialization / deserialization)
    - Efficient (lightweight CPU/memory requirements)

- Polyglot requirements
    - Wide variety of language support
    - Integration with various development platforms/pipelines

: For the challenge of data format, we have three tentpole requirements

## Challenge: Data protocol

- Operates at all levels of CAV ecosystem
    - <b>Edge/CAV</b>: Low-resource/low-bandwidth/low-latency environment
    - <b>Cloud</b>: infinite resources/high-latency (depending on data gravity)

- Machine-to-Machine focused
    - Human interfaces should not be a priority
    - Can transverse heterogenous networks

- Similar Polyglot requirements
    - Wide variety of language support
    - Integration with various development platforms/pipelines

## Challenge: 1st through 3rd party integration

Massive difference between platforms

`CAV ⇄ Edge ⇄ Cloud`:

- Scale of Resources
- Variety of Services
- Varying Intervals of Delivery

<hr style="margin: 2em 0 1.5em 0"/>

Integrators nightmare, e.g. the same camera could be:
- In a different sensor package
- Sold from a different vendor/Valued Added Reseller (VAR) with "added" services
- Installed in a proprietary way by a different OEM

## Extensible Edge Computing Architecture

<div style="text-align:center; margin-top: 1em">
Driven by the inevitability of microservices<br/>
<img src="images/netflix_reduced.png" width=300/> &emsp;&emsp;
<img src="images/netflix_actual.png" width=300/>
</div>

.caption Netflix's microservice Death Star

<hr/>

Contains three parts:

- Data format: `protobuf` (Protocol buffers)

- Data protocol: `gRPC`

- Application orchestration: *k3s* (lightweight kubernetes), *k3OS* (kubernetes OS)

: These choices are driven by the needs of microservices and will be discussed on the following slides.

## Protocol buffers

Two kinds of problems solved:
- Technical 
- "Cultural"

: In the following slides I'll discuss some of the technical problems that Protobuf solves

<hr style="margin: 2em 0 1.5em 0"/>

Comparisons:
- ASN.1
- XML
- CORBA
- JSON
- Thrift
- Avro

: In my work I compare and discuss competing formats, but in the interest of time it's not 100% relevant to this presentation.

## Protocol buffers: Background

- Designed ~2001, evolved out of need for "web-scale" communication in data centers
- Compact, binary serialization
- Interface Definition Language to define models, compiles to interfaces for targets

<hr style="margin: 1em 0 0 0"/>

<table cellspacing="0" cellpadding="0" style="margin: 0; border:none;text-align:center">
<tr><td colspan=2 style="border: none;">Serialization benchmark comparing Protobuf and JSON</td></tr>
<tr>
<td style="border: none;"><img src="images/pb1.png" height=330/></td>
<td style="border: none;"><img src="images/pb2.png" height=330/></td>
<tr/>
<tr><td colspan=2 style="border: none;color:#666;margin-left: 30%;font-size:0.75em">
Protobuf in <span style="color:black">dark gray</span>, with JSON in <span style="color:Gray">light gray</span>. 
Serialization is solid, while deserialization is hatched.</td></tr>
</table>

: Technically, protobufs achieve the requirements for constrained-resource communication.

## Protocol buffers: Example serialized

.image images/example_proto_decomposition.png _ 1000 
<div style="color:#666;margin-left: 30%;font-size:0.75em">
    Example message composed of three fields: 
    <ul>
    <li>hexadecimal wire values shown in <span style="color:black"><i>black</i></span>, </li>
    <li>with decoded values and field descriptions in <span style="color:green"><i>green</i></span></li>
    </ul>
</div>

: The binary example of a protobuf message with three fields:
: User's full name
: User's system ID
: User's email address
: Comparably, an equivalent JSON message would be 75 bytes without whitespace minification.

## Protocol buffers: Example model

.code -numbers code/person.proto
.caption 'Person' model containing fields for Name, ID, Email and multiple phone numbers.

## gRPC

Problems solved:
- New application paradigm ➔ Monolith vs Microservices
- Layered communications crossing network stacks, data centers and regions ("fleet")
- Built-in `JSON⬌gRPC` gateway enables legacy clients, or where `.proto` files are inaccessible to consumers

<hr style="margin: 2em 0 1.5em 0"/>

Comparisons:
- JSON over HTTP
- Thrift RPC
- CoAP

## gRPC: Background

- Released ~2015, designed for massively distributed services spanning data centers
- While not tied directly to Protobufs, uses the same IDL
- "Rides" on HTTP/2, and already tested with HTTP/3

<hr style="margin: 1em 0 0 0"/>
<table  cellspacing="0" cellpadding="0" style="margin: 0; border:none;text-align:center">
<tr><td style="border: none;">Heartbeat benchmarks comparing Protobuf and JSON</td></tr>
<tr><td style="border: none;"><img src="images/heartbeat_benchmark.png" height=330/></td></tr>
<tr><td style="border: none;color:#666;margin-left: 30%;font-size:0.75em">   
    gRPC is in <span style="color:black"><i>dark gray</i></span> and JSON over HTTP is in <span style="color:Gray"><i>light gray.</i></span>
</td></tr>
</table>

: Like many RPC implementations, gRPC uses a server to receive messages, and unmarshal them into data objects. 

## gRPC: Architecture stack

.image images/grpc-core-stack.svg 520 _
.caption "Wrapped" languages: `gRPC` C-Core stack

: gRPC provides three different stacks: a C-Core stack, a Java stack, and a Golang stack.  The C-Core stack is show here and wraps C-based languages.  In green are the networking protocols available.

## gRPC: Example service

.code -numbers code/contacts.proto
<div style="color:#666;text-align: center;font-size:0.75em;margin-top: -0.75em">
'Contacts' service model with an endpoint for Creation, Getting, and Listing.
</div>

: Continuing the "Person" example is an address book service.  This provides three remote methods: Create, Get and List.  Once compiled with protoc, the implementations can be filled in with whatever language the architecture requires.
: Of note are the HTTP "options"... these provide the JSON endpoints for the JSON to gRPC gateway and allow legacy JSON clients to communicate to the gRPC services.  This is exactly how Google's API function with JSON and XML.

## Protocol buffers/gRPC development lifecycle

.image images/protobuf_lifecycle.png _ 950
.caption Protocol buffer and gRPC developer workflow

## Application orchestration

- Portable application deployment
- Network topology is "unstable" &hellip; clusters should form to do "work" dynamically
- Multi-cloud capable (from edge clusters to public cloud providers)

<hr style="margin: 2em 0 -0.5em 0"/>

.image images/virtualization-vs-containers.png 240 _
.caption Type 1 and Type 2 virtualization compared to containerization

<div style="text-align: center; margin-top: 1.5em"><i>Virtualization and containerization is not enough</i></div>

## k3s

<div><b>containerization</b> = abstracting applications' runtime environment</div>
<div><b>kubernetes (k8s)</b> = abstracting applications' runtime scheduling</div>

.image images/k3s_overview.svg 450 _
.caption k3s overview of a Server and Agent

: kubernetes is abbreviated as k8s, and has become the standard for application orchestration in the last decade.
: To enable code-driven, highly available and resilient microservices was a major driving force.
: Really about abstracting away from the underlying container daemon, operating system, network, and storage.

## k3os

Just like the kernel schedules processes in an operating system;<br/>
&emsp;k8s schedules applications in a data center

.image images/k3os_overview.svg 440 _
.caption k3os overview of a VM

## My other research: Cloud related

- Reliability Characterization of Solid State Drives in a Scalable Production Data Center
- Incorporate Proactive Data Protection in ZFS Towards Reliable Storage Systems
- Developing Cost-Effective Data Rescue Schemes to Tackle Disk Failures in Data Centers
- An Empirical Study of Quad-Level Cell (QLC) NAND Flash SSDs for Big Data Applications

.image images/pdp_baseline.png _ 630
<div style="color:#666 ;text-align: center;font-size:0.75em; line-height: 30px">Proactive disk cloning and post-failure disk recovery for a fully-utilized <i>zpool</i>. <b>0H</b> denotes the disk failure occurrence.</div>

## My other research: Proactive data protection

Disk access speed has been outpaced by the increasing capacity.  

The stripe width of RAID arrays have grown to fill the gap between disk speed and capacity. 

Unfortunately, the probability of having double and even triple failures also increases as the disk recovery time is significantly prolonged

<hr/>

In this work a Proactive Data Protection (**PDP**) framework is proposed to reduce the recovery time for RAID systems in ZFS.

**PDP** chooses among one of three strategies based upon real-time characteristics of the RAID pools to provide the quickest, most cost-effective recovery for data center storage.

## My other research: Proactive data protection

Three strategies:

1. Proactive Disk Cloning (P-DISCO)

     Migrates data on a predicted, failing drive to a hot spare using disk cloning.

<hr/>

2. Proactive Active-data Recovery (P-ADAR)

    Proactively  rescues  only  active-data  to  the  spares, although computationally intensive,  recovering only the minimum amount  of  necessary  data  can  save  time. 

<hr/>

3. Proactive Active-data Cloning (P-DACO)

      Only clones the active data during rescue, and eliminates the need to compute parity (combination of #1 and #2 strategies). 

## My other research: Proactive data protection

.image images/pdp_strategy.png _ 950
.caption Time used by each proactive strategies for data rescue.

## My other research: Edge related

- TuranGo:  Mutation Testing a Language
- Optimal Police Patrol Planning Strategy for Smart City Safety

.image images/patrols_density.png 430 _
<div style="color:#666 ;text-align: center;font-size:0.75em; line-height: 30px">LA County crime <i>stat_density2d</i> plot with size=1, bins=128.</div>

## My other research: Police Patrol Planning

Police are not an infinite resource and must be managed effectively to reduce overall crime.  

This work uses a novel approach to police patrol placement by using the following workflow: 

1. Process crime data set: statistical analysis, remove "bad" data, assign crime weights
2. Cluster crime centroids by quantity and weight
3. Use historical traffic information for distance calculation between these centroids
3. Maximize entropy by placement of police patrols on the cluster centroids

## My other research: Police Patrol Planning

LA County was chosen for three reasons:
1. Lower external variables (namely weather stability)

     LA County: low of 8.6°C to a high of 23.5°C with 380mm rain <br/>
     Cook (Chicago): low of -10.8°C to a high of 28.6°C with 940mm rain

<hr/>

2. Long drive distances to take advantage of the entropy calculation

    LA County: 12,300 km<sup>2</sup> <br/>
    Cook (Chicago): 4,235 km<sup>2</sup>

<hr/>

3. Open, consistent data

     The Los Angeles Open Data project provides crime data for LA County, and in total comprised 2,130,504 crimes from 2005 to 2015.

## My other research: Police Patrol Planning

Number of clusters chosen from hexbin plots. 

50 clusters plotted using K-means (weighted crimes replicated).

Drive distances between all the centroids retrieved using historical traffic data.

Patrols placed to maximize entropy using: 

.image images/patrols_entropy.png _ 650
<div style="color:#666 ;text-align: center;font-size:0.75em; line-height: 30px">The entropy is a combination of the weight of a crime centroid (w<sub>c1</sub>), 
generated from crime clustering, over the total system weight (w<sub>sys</sub>), 
added to the quickest path from the centroid to any other centroid (r<sub>c1</sub>), 
over the quickest path in the entire system (r<sub>sys</sub>)<div>


## My other research: Police Patrol Planning

.image images/patrols_placed.png 530 _
.caption 50 crime clusters with 25 patrols placed using entropy algorithm. Black cross-hairs show placed patrols.

## My other research: CAV related

- Embedded Deep Learning for Vehicular Edge Computing
- Low-Latency High-Level Data Sharing for Connected and Autonomous Vehicular Networks

.image images/ncs_fps.png _ 750
.caption GoogLeNet CNN classifier: RPi3B + VCS versus Desktop + VCS

## My other research: Embedded Deep Learning

The proliferation of resource-constrained edge devices has pushed development of supplementary AI-specific devices for inference on already trained models. 

.image images/rpi3b_diagram.png 350 _
.caption The Raspberry Pi 3 Model B used in my experiments contains a 1.2gHz 64-bit quad-core Cortex-A53 (ARMv8) CPU, 1GB of low-power DDR2 SDRAM and four USB 2.0 ports via on-board 5-port USB hub, drawing 6.7W at peak load.

## My other research: Embedded Deep Learning

The AI stick is a USB device containing a specialized processing unit, in this case a Vision Processing Unit (VPU). 

This VPU is optimized to execute models in TensorFlow and Caffe frameworks. 

.image images/ncs_vpu.png 350 _
.caption Intel™ Movidius® Neural Compute Stick (NCS) is a tiny fanless, USB 3.0 Type-A deep learning device containing a Myriad 2  Vision Processing Unit producing almost 100 GFLOPS while only using 1W of power.

## My other research: Embedded Deep Learning

.image images/ncs_fps_mobilnets.png 540 _
.caption MobileNets RPi3B (FPS): CPU only vs.  1 x NCS

## Conclusion

.image images/example_mgmt.png _ 1024 
.caption Example Node management platform using Protobufs as data format for serialization and storage, along with gRPC for remote service calls.

## Conclusion

.image images/example_edge.png _ 1024 
.caption Example Edge node using application orchestration to deploy two Pods for microservices.

## Future work

- Large scale testing of Edge clusters using kubernetes OS, as miles of road can be simulated with a few small-board computers
- Creation of Edge-focused Trust Management Platform
- Negotiation and sharing of data between Edge and CAV systems

.image images/cattle_pi.png _ 650 
.caption k3s Raspberry Pi cattle case for Rancher cluster (Mark Abrams 2019)


## Publications

- <i>Embedded deep  learning  for  vehicular  edge  computing</i>, <br/>&emsp;2018 IEEE/ACM  Symposium on Edge Computing (SEC)
- <i>An optimal police patrol planning strategy for smart city safety</i>,  <br/>&emsp;2016 IEEE  14th  Intl. Conf.  on Smart City
- <i>Low-latency high-level data sharing for connected and autonomous vehicular networks</i>, <br/>&emsp;2019 IEEE Intl. Conf. on Industrial Internet (ICII)
- <i>Reliability characterization  of  solid  state  drives  in  a  scalable  production  data center</i>,  <br/>&emsp;2018 IEEE Intl. Conf. on Big Data (Big Data)
- <i>An empirical study of quad-level cell (QLC) NAND flash SSDs for big data applications</i>,  <br/>&emsp;2019 IEEE Intl. Conf. on Big Data (Big Data)
- <i>Incorporate proactive data protection in ZFS towards reliable storage systems</i>,  <br/>&emsp;2018 IEEE Intl. Conf. on Big Data Intelligence and Computing(DataCom)
- <i>Developing cost-effective data rescue schemes to tackle disk failures in data centers</i>, <br/>&emsp;2018 Intl. Conf. on Big Data
